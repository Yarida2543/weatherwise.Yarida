Topic: Implementing and refining the get_weather_data() function

Tool: ChatGPT
Date: 2025-10-17

Me:
Alright,I already set up the API keys for my WeatherWise project. Now I want to write a function to get weather data from the OpenWeather API. Can you help me plan the structure before I start coding?

AI:
Sure! Let's restate your problem:
You want a Python function that takes a city name and optionally a number of forecast days (1–5) as input, retrieves the data from the OpenWeather API, and returns it in a clean dictionary format.

Here’s a basic structure to start with:

def get_weather_data(city: str, forecast_days: int = 5) -> dict:
    """
    Retrieve weather data for a specified location.
    """
    # Step 1: Validate input
    # Step 2: Call your helper function to fetch data from API
    # Step 3: Parse and group the data by day
    # Step 4: Return results as a dictionary


You’ll need helper functions for:

Fetching raw JSON data (Get_data_from_Web)

Processing daily summaries (_process_daily_forecast_items)

Me:
I already have a helper called Get_data_from_Web(city, units) that returns OpenWeather’s 5-day forecast JSON. How can I group that data by each day?

AI:
Good — OpenWeather’s forecast API returns data in 3-hour intervals.
To group them by day:

Extract the date from item["dt_txt"].split(" ")[0]

Store them in a dictionary keyed by date

Later, you can loop through each day’s items and summarise

Example:

daily_data = {}
for item in response_data["list"]:
    date_str = item["dt_txt"].split(" ")[0]
    daily_data.setdefault(date_str, []).append(item)


Then you can calculate averages or daily summaries with a helper like _process_daily_forecast_items().

Me:
Okay, I’ll use that. I also want to make sure users don’t enter invalid cities. How do I add validation?

AI:
Good point! You can validate input before making the API call:

if not city or not isinstance(city, str):
    result["error"] = "Invalid location provided. Please enter a city name."
    return result


This prevents unnecessary API requests and improves program stability.

Me:
Nice. After grouping, how do I only include forecasts for the next few days? For example, 3 or 5 days depending on user input.

AI:
You can use datetime to generate a list of date strings for the days you want to include:

from datetime import datetime, timedelta
today = datetime.now().date()
dates_to_include = [(today + timedelta(days=i)).strftime("%Y-%m-%d") for i in range(result["forecast_days"])]


Then only process data for those dates.

Me:
That’s clear. What about “current weather”? The OpenWeather API uses a different endpoint for that, but can I just take the first forecast of today?

AI:
Yes, that’s a simple and effective shortcut. You can extract the first forecast item if its date equals today:

first_item = response_data["list"][0]
if first_item["dt_txt"].split(" ")[0] == today.strftime("%Y-%m-%d"):
    result["current"] = {
        "temp_C": first_item["main"]["temp"],
        "FeelsLike": first_item["main"]["feels_like"],
        "weatherDescript": first_item["weather"],
        "precipi_MM": first_item.get("rain", {}).get("3h", 0),
        "wind_speed": first_item["wind"]["speed"] * 3.6,
        "wind_degrees": None
    }


That gives you a reasonable “current” snapshot without needing another API call.

Me:
I see. If something goes wrong with the API call, should I check for an "error" key?

AI:
Exactly. Handle both “no response” and “error” cases:

elif response_data and response_data.get("error"):
    result["error"] = response_data["error"]
else:
    result["error"] = "Failed to retrieve weather data."


This ensures your function always returns a consistent dictionary, even if something fails.

Me:
Alright, here’s my complete version now:

def get_weather_data(city: str, forecast_days: int = 5):
    result: ParsedWeather = {
        "location": city,
        "forecast_days": max(1, min(int(forecast_days or 5), 5)),
    }

    if not city or not isinstance(city, str):
        result["error"] = "Invalid location provided. Please enter a city name."
        return result

    response_data = Get_data_from_Web(city=city, units="metric")

    if response_data and "list" in response_data:
        daily_forecasts = []
        daily_data = {}
        for item in response_data["list"]:
            date_str = item["dt_txt"].split(" ")[0]
            daily_data.setdefault(date_str, []).append(item)

        from datetime import datetime, timedelta
        today = datetime.now().date()
        dates_to_include = [(today + timedelta(days=i)).strftime("%Y-%m-%d") for i in range(result["forecast_days"])]

        for date_str in dates_to_include:
            if date_str in daily_data:
                day_items = daily_data[date_str]
                daily_summary = _process_daily_forecast_items(day_items, date_str)
                if daily_summary:
                    daily_forecasts.append(daily_summary)

        result["daily"] = daily_forecasts

        if response_data["list"]:
            first_item = response_data["list"][0]
            if first_item["dt_txt"].split(" ")[0] == today.strftime("%Y-%m-%d"):
                result["current"] = {
                    "temp_C": first_item["main"]["temp"],
                    "FeelsLike": first_item["main"]["feels_like"],
                    "weatherDescript": first_item["weather"],
                    "precipi_MM": first_item.get("rain", {}).get("3h", 0),
                    "wind_speed": first_item["wind"]["speed"] * 3.6,
                    "wind_degrees": None
                }

    elif response_data and response_data.get("error"):
        result["error"] = response_data["error"]
    else:
        result["error"] = "Missed to recover the weather forecast data."

    return result


AI:
Excellent! This function is well-structured — it validates input, processes multi-day data, handles errors, and uses helper functions for modularity.
You’ve implemented strong prompting techniques such as:

Asking for code structure before implementation

Handling validation and error cases

Discussing design trade-offs (current data vs. extra API call)

Iteratively improving from pseudocode to a working function

Me (reflection):
Through this conversation, I learned how to process and summarise multi-day weather forecasts from an API and how to manage error handling systematically. It also helped me understand why modular functions make the code cleaner and easier to debug.
