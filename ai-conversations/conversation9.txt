Topic: Designing the ask() function for user interaction
Purpose: Demonstrate modular input handling and adaptability to different execution environments

Tool: ChatGPT
Date: 2025-10-18

Me:
Now I want to add a simple way for users to interact with my WeatherWise system. I want to display menu options using pyinputplus, but I also need a fallback in case it’s not installed. How can I make a small helper function for that?

AI:
That’s a good design improvement
Let’s restate your goal:
You want a reusable input function that:

Uses pyinputplus if it’s available

Shows menu-style options when choices are provided

Falls back to a basic text input if pyinputplus isn’t installed

This can make your system more interactive and consistent.

Here’s a starting structure:

def ask(prompt: str, choices: Optional[List[str]] = None) -> str:
    if pyip and choices:
        return pyip.inputMenu(choices, prompt=prompt + "\n", numbered=True)
    elif pyip:
        return pyip.inputStr(prompt)
    else:
        return input(prompt + ": ")


Me:
That works, but in my environment, I sometimes don’t have pyinputplus installed, and I’d rather raise an error instead of using the regular input() function. How can I do that safely?

AI:
Great reasoning  — if you want strict control (for example, in automated testing or restricted notebooks), you can remove the fallback and raise an EnvironmentError instead.
Like this:

def ask(prompt: str, choices: Optional[List[str]] = None) -> str:
    if pyip and choices:
        return pyip.inputMenu(choices, prompt=prompt + "\n", numbered=True)
    elif pyip:
        return pyip.inputStr(prompt)
    else:
        raise EnvironmentError("pyinputplus is not available.")


This clearly tells the user (or tester) that the dependency is missing, instead of silently using a weaker alternative.

Me:
Makes sense. So my final version should look like this?

def ask(prompt: str, choices: Optional[List[str]] = None) -> str:
    if pyip and choices:
        return pyip.inputMenu(choices, prompt=prompt + "\n", numbered=True)
    elif pyip:
        return pyip.inputStr(prompt)
    else:
        # basic fallback - REMOVED
        # return input(prompt + (f" ({'/'.join(choices)})" if choices else "") + ": ")
        raise EnvironmentError("pyinputplus is not available.")


AI:
Exactly 
That’s clean, professional, and consistent with your modular design style.
It’s:

Flexible: Handles both menu and free-text modes

Clear: Raises explicit errors when dependencies are missing

Safe: Prevents unintentional behaviour differences across environments

This function ties your entire user flow together — users can now navigate through menu options or type custom queries directly.

Me:
Perfect. I tested it in my local environment, and it worked smoothly. It also raised the correct error when I uninstalled pyinputplus. I understand now how to make interactive features robust even in limited environments.
